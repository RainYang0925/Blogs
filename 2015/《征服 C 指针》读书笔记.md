#《征服 C 指针》读书笔记
##第3章
###1.const关键词
####1）语法和使用简介
为了标识传入函数的指针类型的形参『只读』，函数内部无法改变指针所指向的实参的值。
C函数的返回值一般为 int，标识该函数是否执行成功。
const 修饰紧跟在它后面的词(注意是英语语法)，例如
char *const src; // src is read-only pointer to char.
char const *src; // src is pointer to  read-only char.
const char *src; // 同上
####2）什么时候使用？
为了标识形参属于输入（i）、输出(o)还是输入/输出(i/o)类型，又不想写过多注释，可以用 const 来标注『输入』类型的形参，比写注释好的地方是，编译器可以帮助检查错误，如果对『输入』类型的形参赋值则会编译器报错。

**注意**：一旦给指针类型的参数设定了 const,当前层次以下的函数必须全部使用 const*.

将 const char* 传给 char*类型的形参是错误的。

####3）const 能替代#define 吗？
不能！这两个语法是完全不同的。const 表示只读，预处理语句可用来定义常量。若 const 修饰一个常量，则代表其『只读』的特性，而不代表这是一个常量。

###2.typedef 关键词
用于给某类型定义别名,是存储类型修饰符。
例如， typedef char *String;
typedef 声明自定义类型时，同标识符声明一样，只是被声明的不是变量或函数，而是自定义类型。

多用于自定义结构体类型。

也可以一次声明多个别名：
```
typedef struct {
::
} Hoge, *HogeP;
```
等同于：
```
typedef struct {
:
: } Hoge;
typedef Hoge *HogeP;
```
但为了增强代码可读性，不建议一次声明多个别名。

###3.其他
####1）在声明函数形参时，int a[]被自动转换为 int *a。
看到 int a[]作为函数形参时，不必怀疑『C 语言中，数组不是不可以作为函数参数进行传递吗？』，此处的 int a[]并不是数组，而是指针。

在表达式中的数组可以被理解为`指向数组首元素的指针`，函数的参数也是表达式，因此也可以被理解为`指向数组首元素的指针`，因此，作为形参的 int a[]传递给函数的实际是一个指针。

这里的空方括号是 C 语言早期为了便于移植而设计的规则之一，属于遗留的旧规则，对现在的语法理解产生混乱，但也没辙了。。
####2）空的下标运算符[]
* `函数形参的声明`：会被解读为指针，即使定义了个数也会被无视；
* `根据表达式可以确定数组大小`：例如，int    a[] = {1, 2, 3, 4, 5}; char   str[] = "abc";
* `用 extern 声明全局变量时`：

**注意**区分声明和定义的区别：对于函数来说，声明就是函数的原型，定义就是函数实际执行的代码部分。声明可以没有定义，但定义一定需要先声明。

####3）字符串常量
"abc"  是字符串常量，实际是 `char 类型的数组`。可以将它赋值给一个`指向 char 的指针`，也可以赋值给 char 类型数组（char str[]="abc";）。相当于 char str[] = {'a','b','c','\0'};

####4）指向函数的指针
表达式中的函数自动转换为`指向函数的指针`，跟数组一样（指向数组首元素的指针）。

####5）强制类型转换
分为基本类型的强转、指针类型强转（实际是对指针进行强制读取转换）；
为了程序的可移植性，要避免指针类型强转，同时，不要用强转来掩盖编译器警告。

###4.数组和指针是不同的事物


